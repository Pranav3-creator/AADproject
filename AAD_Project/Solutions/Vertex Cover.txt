"""
Exact and 2-approximation algorithms for Vertex Cover + benchmarking and plots.

Graph stored as adjacency list: Dict[int, Set[int]].

This file:
- Implements:
    * add_edge
    * exact_branching (exact exponential VC)
    * approx_2 (2-approximation)
- Benchmarks both algorithms on random graphs
- Produces two plots:
    1) Runtime vs n (exact vs approx)
    2) Vertex cover size vs n (exact vs approx)
"""

from typing import Dict, Set, Tuple, List
import random
import time
import matplotlib.pyplot as plt

Graph = Dict[int, Set[int]]


# =========================================================
#  Vertex Cover Algorithms (your original code)
# =========================================================

def add_edge(g: Graph, u: int, v: int):
    """
    Insert an undirected edge into the adjacency list graph.

    Args:
        g: Graph adjacency dict.
        u: First endpoint.
        v: Second endpoint.
    """
    g.setdefault(u, set()).add(v)
    g.setdefault(v, set()).add(u)


def any_edge(g: Graph):
    """
    Return an arbitrary edge (u, v) with u < v, or None if graph is edgeless.

    Args:
        g: Graph adjacency dict.
    Returns:
        Tuple (u, v) or None.
    """
    for u, nbrs in g.items():
        for v in nbrs:
            if u < v:
                return (u, v)
    return None


def remove_vertex(g: Graph, u: int) -> Graph:
    """
    Remove vertex u and its incident edges.

    Args:
        g: Graph adjacency dict.
        u: Vertex to delete.
    Returns:
        A shallow copy of g with u removed.
    """
    g2 = {x: set(nbrs) for x, nbrs in g.items()}
    for v in list(g2.get(u, [])):
        g2[v].discard(u)
    g2.pop(u, None)
    return g2


def exact_branching(g: Graph, k: int) -> Tuple[bool, List[int]]:
    """
    Exponential branching algorithm deciding if there is a vertex cover of size ≤ k.

    The recursion aborts immediately once k < 0, so any successful result
    satisfies len(cover) ≤ the original k budget.
    """
    if k < 0:
        # We have already picked more than k vertices
        return False, []

    e = any_edge(g)
    if e is None:
        # No edges left, current choice of vertices is a valid cover within k
        return True, []

    u, v = e
    sat, cover = exact_branching(remove_vertex(g, u), k - 1)
    if sat:
        return True, cover + [u]
    sat, cover = exact_branching(remove_vertex(g, v), k - 1)
    if sat:
        return True, cover + [v]
    return False, []


def approx_2(g: Graph) -> List[int]:
    """
    Greedy 2-approximation for vertex cover by picking both endpoints of uncovered edges.

    Args:
        g: Graph adjacency dict.
    Returns:
        List of vertices forming a 2-approximate cover.
    """
    g2 = {x: set(n) for x, n in g.items()}
    cover: List[int] = []
    while True:
        e = any_edge(g2)
        if e is None:
            break
        u, v = e
        cover += [u, v]
        g2 = remove_vertex(remove_vertex(g2, u), v)
    return cover


# =========================================================
#  Helpers: Random Graph & Exact Cover Size
# =========================================================

def random_graph(n: int, p: float) -> Graph:
    """
    Generate a random undirected graph on {0..n-1},
    with edge probability p.
    """
    g: Graph = {i: set() for i in range(n)}
    for i in range(n):
        for j in range(i + 1, n):
            if random.random() < p:
                add_edge(g, i, j)
    return g


def exact_min_vertex_cover_size(g: Graph) -> Tuple[int, List[int], float]:
    """
    Compute the exact minimum vertex cover size by trying k = 0..n.

    Returns:
        (k_opt, cover_vertices, time_taken)
    """
    n = len(g)
    t0 = time.time()
    best_cover: List[int] = []
    for k in range(n + 1):
        sat, cover = exact_branching(g, k)
        if sat:
            best_cover = cover
            t1 = time.time()
            return len(cover), cover, (t1 - t0)
    # In theory, we always find something by k = n
    t1 = time.time()
    return n, best_cover, (t1 - t0)


# =========================================================
#  Benchmark + Plots
# =========================================================

def benchmark_vertex_cover():
    random.seed(0)

    # Keep n small because exact VC is exponential
    sizes = list(range(4, 13))   # n = 4..12
    p = 0.4                      # edge probability

    exact_times: List[float] = []
    approx_times: List[float] = []
    exact_sizes: List[int] = []
    approx_sizes: List[int] = []

    for n in sizes:
        g = random_graph(n, p)

        # Exact VC (min size) via branching
        k_opt, cover_exact, t_exact = exact_min_vertex_cover_size(g)

        # Approx VC (2-approx)
        t0 = time.time()
        cover_approx = approx_2(g)
        t1 = time.time()
        t_approx = t1 - t0

        exact_times.append(t_exact)
        approx_times.append(t_approx)
        exact_sizes.append(len(cover_exact))
        approx_sizes.append(len(cover_approx))

        print(
            f"n={n:2d} | exact_size={len(cover_exact)}, "
            f"approx_size={len(cover_approx)}, "
            f"exact_time={t_exact:.6f}s, approx_time={t_approx:.6f}s"
        )

    # ---- Plot 1: Runtime vs n ----
    plt.figure()
    plt.plot(sizes, exact_times, marker="o", label="Exact branching")
    plt.plot(sizes, approx_times, marker="o", label="2-approx greedy")
    plt.xlabel("Number of vertices (n)")
    plt.ylabel("Runtime (seconds)")
    plt.title("Vertex Cover: runtime vs problem size")
    plt.legend()
    plt.grid(True)

    # ---- Plot 2: Cover size vs n ----
    plt.figure()
    plt.plot(sizes, exact_sizes, marker="o", label="Exact min cover size")
    plt.plot(sizes, approx_sizes, marker="o", label="2-approx cover size")
    plt.xlabel("Number of vertices (n)")
    plt.ylabel("Size of vertex cover")
    plt.title("Vertex Cover: exact vs 2-approx cover size")
    plt.legend()
    plt.grid(True)

    plt.show()


if _name_ == "_main_":
    benchmark_vertex_cover()