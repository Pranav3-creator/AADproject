from itertools import product
import matplotlib.pyplot as plt
import networkx as nx

# -1 = unknown cell (could be mine)
#  0..8 = revealed clues
BOARD = [
    [1, 2, -1, 1],
    [1, -1, 3, 2],
    [1, 2, -1, 1],
    [0, 1, 1, 1],
]


# -----------------------------
#  Basic helpers
# -----------------------------
def in_bounds(r, c, rows, cols):
    return 0 <= r < rows and 0 <= c < cols


def neighbors(r, c, rows, cols):
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = r + dr, c + dc
            if in_bounds(nr, nc, rows, cols):
                yield nr, nc


def collect_unknowns(board):
    rows, cols = len(board), len(board[0])
    unknowns = []
    for r in range(rows):
        for c in range(cols):
            if board[r][c] == -1:
                unknowns.append((r, c))
    return unknowns


# -----------------------------
#  NP verifier + solver
# -----------------------------
def verify_assignment(board, mines):
    """
    Polynomial-time verifier:
    returns True if all clues are satisfied by this mine placement.
    """
    rows, cols = len(board), len(board[0])

    for r in range(rows):
        for c in range(cols):
            val = board[r][c]
            if val >= 0:  # it's a clue
                cnt = 0
                for nr, nc in neighbors(r, c, rows, cols):
                    if (nr, nc) in mines:
                        cnt += 1
                if cnt != val:
                    return False
    return True


def has_consistent_assignment(board):
    """
    Exponential brute-force solver for MINESWEEPER-CONSISTENCY.
    Only good for small boards, but fine for our demo.
    """
    unknowns = collect_unknowns(board)
    k = len(unknowns)

    for bits in product([0, 1], repeat=k):
        mines = {unknowns[i] for i in range(k) if bits[i] == 1}
        if verify_assignment(board, mines):
            return True, mines

    return False, None


# -----------------------------
#  Constraint graph construction
# -----------------------------
def build_minesweeper_graph(board):
    """
    Build the Minesweeper constraint graph (bipartite).

    Variable nodes: ("var", r, c) for unknown cells board[r][c] == -1
    Constraint nodes: ("clue", r, c) for numbered cells board[r][c] > 0
    Edge between ("clue", r, c) and ("var", r2, c2) if (r2,c2) is adjacent to (r,c).
    """
    rows, cols = len(board), len(board[0])

    G = nx.Graph()
    var_nodes = []
    clue_nodes = []

    for r in range(rows):
        for c in range(cols):
            val = board[r][c]
            if val == -1:
                node = ("var", r, c)
                var_nodes.append(node)
                G.add_node(node, kind="var")
            elif val > 0:
                node = ("clue", r, c)
                clue_nodes.append(node)
                G.add_node(node, kind="clue")

    # Edges: each clue connected to adjacent variables
    for r in range(rows):
        for c in range(cols):
            val = board[r][c]
            if val > 0:
                clue_node = ("clue", r, c)
                for nr, nc in neighbors(r, c, rows, cols):
                    if board[nr][nc] == -1:
                        var_node = ("var", nr, nc)
                        if var_node in G:
                            G.add_edge(clue_node, var_node)

    return G, var_nodes, clue_nodes


# -----------------------------
#  Drawing function
# -----------------------------
def draw_minesweeper_graph(board, mines=None):
    """
    Draw the Minesweeper constraint graph.

    If 'mines' is given (set of (r,c)), those variable nodes are marked as M.
    """
    G, var_nodes, clue_nodes = build_minesweeper_graph(board)

    rows, cols = len(board), len(board[0])
    pos = {}

    # Split variable nodes into mines vs non-mines (if solution given)
    mine_nodes = []
    safe_var_nodes = []

    if mines is None:
        safe_var_nodes = var_nodes
    else:
        for node in var_nodes:
            _, r, c = node
            if (r, c) in mines:
                mine_nodes.append(node)
            else:
                safe_var_nodes.append(node)

    # Place nodes roughly on a grid; clues slightly above, vars slightly below
    for kind, nodes, y_offset in [
        ("var", var_nodes, -0.1),
        ("clue", clue_nodes, +0.1),
    ]:
        for _, r, c in nodes:
            pos[(kind, r, c)] = (c, -r + y_offset)

    plt.figure(figsize=(6, 6))

    # Edges
    nx.draw_networkx_edges(G, pos)

    # Unknown non-mine variables
    if safe_var_nodes:
        nx.draw_networkx_nodes(
            G,
            pos,
            nodelist=safe_var_nodes,
            node_shape="o",
            node_size=800,
        )

    # Variable nodes that are mines in the found solution
    if mine_nodes:
        nx.draw_networkx_nodes(
            G,
            pos,
            nodelist=mine_nodes,
            node_shape="o",
            node_size=900,
        )

    # Clue nodes (numbers)
    nx.draw_networkx_nodes(
        G,
        pos,
        nodelist=clue_nodes,
        node_shape="s",
        node_size=800,
    )

    # Labels
    labels = {}
    for node in G.nodes:
        kind, r, c = node
        if kind == "var":
            if mines is not None and (r, c) in mines:
                labels[node] = "M"
            else:
                labels[node] = "?"
        else:
            labels[node] = str(board[r][c])

    nx.draw_networkx_labels(G, pos, labels=labels, font_size=10)

    plt.title("Minesweeper Constraint Graph (Variables vs Clues)")
    plt.axis("off")
    plt.tight_layout()
    plt.show()


# -----------------------------
#  Main
# -----------------------------
if _name_ == "_main_":
    ok, mines = has_consistent_assignment(BOARD)
    if ok:
        print("Board is consistent. One valid mine layout is:")
        print(mines)
    else:
        print("Board is inconsistent: no mine layout fits all clues.")
        mines = None  # no layout to highlight

    # Draw the graph (highlighting mines if found)
    draw_minesweeper_graph(BOARD, mines)
